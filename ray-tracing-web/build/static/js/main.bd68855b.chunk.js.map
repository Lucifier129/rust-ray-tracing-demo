{"version":3,"sources":["pure-js/ray-tracing.js","pure-js/index.js","rust-wasm/index.tsx","rust-wasm/small.tsx","index.tsx","pure-js/lib/runtime.js"],"names":["vec3","require","_add_","_sub_","_mul_","_div_","_negate_","from","x","y","z","fromValues","dot","vec3a","vec3b","cross","create","normalize","Ray","a","b","time","this","t","lerp","start","end","createRecord","p","normal","Sphere","center","radius","material","ray","tmin","tmax","record","oc","origin","direction","c","discriminant","temp","Math","sqrt","isValid","pointAt","MovingSphere","center1","center2","time1","time2","sphere","setCenter","hit","HitableList","list","tempRecord","hited","closest","Object","assign","push","Camera","lookFrom","lookAt","vup","vfov","aspect","aperture","focusDist","theta","PI","halfHeight","tan","halfWidth","w","u","v","lowerLeftCorner","horizontal","vertical","lensRadius","s","rd","randomVec3","random","randomInUnitDisk","offset","randomInUnitSphere","squaredLength","LambertianMaterial","albedo","ref","target","scattered","attenuation","reflect","n","MetalMaterial","fuzz","min","reflected","DielectricMaterial","refractIndex","outwardNormal","ni_over_nt","consine","dotResult","length","refractProb","uv","dt","refracted","refract","r0","pow","schlick","width","height","amount","nx","ny","camera","world","range","floor","i","based","chooseMat","randomScene","renderByPosition","color","depth","Infinity","scatter","getRay","render","j","r","g","noop","frame","f","Promise","resolve","requestAnimationFrame","getMSE","listA","listB","sum","incre","step","decre","abs","toggle","valueA","next","valueB","done","value","spread","middle","source","sortByMSE","prev","current","result","index","sort","toColor","RayTracing","props","useState","setTime","useRef","deubgRef","useEffect","canvas","debugCanvas","ctx","getContext","debugCtx","imageData","createImageData","debugImageData","createRayTracing","counts","data","Float32Array","prevImageData","currImageData","renderCount","innerCount","innerTime","tid","over","renderToCanvas","fillColor","clearRect","putImageData","showDebugInfo","Date","now","duration","scheduleRender","count","item","clearTimeout","toFixed","style","background","display","margin","React","lazy","Scene","clientWidth","clientHeight","random_scene","fillStyle","render_by_position","yieldCount","max","handleKeyDown","event","number","key","process_keyboard","document","addEventListener","removeEventListener","default","currentCount","throttle","marginLeft","marginRight","marginTop","transform","Header","Layout","Content","Footer","Components","JavaScript","JsRayTracing","Rust","RustRayTracing","SmallRustRayTracing","App","type","setType","Target","className","theme","mode","selectedKeys","keys","map","name","Item","onClick","padding","fallback","textAlign","href","ReactDOM","getElementById","isVec3","obj","toVec3","module","exports","left","right","add","sub","mul","div","operand","negate"],"mappings":"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","file":"static/js/main.bd68855b.chunk.js","sourcesContent":["const {\n  vec3\n} = require('gl-matrix');\n\nconst {\n  _add_,\n  _sub_,\n  _mul_,\n  _div_,\n  _negate_\n} = require('./lib/runtime');\n\nconst from = (x, y, z) => vec3.fromValues(x, y, z);\n\nconst dot = (vec3a, vec3b) => vec3.dot(vec3a, vec3b);\n\nconst cross = (vec3a, vec3b) => vec3.cross(vec3.create(), vec3a, vec3b);\n\nconst normalize = vec3a => vec3.normalize(vec3.create(), vec3a);\n\nclass Ray {\n  constructor(a, b, time = 0.0) {\n    this.a = a;\n    this.b = b;\n    this.time = time;\n  }\n\n  origin() {\n    return this.a;\n  }\n\n  direction() {\n    return this.b;\n  }\n\n  pointAt(t) {\n    let {\n      a,\n      b\n    } = this;\n    return _add_(a, _mul_(t, b));\n  }\n\n} // linear-blend/linear-interpolation\n\n\nconst lerp = (t, start, end) => _add_(_mul_(_sub_(1.0, t), start), _mul_(t, end));\n\nconst createRecord = () => {\n  return {\n    t: 0,\n    p: vec3.create(),\n    normal: vec3.create()\n  };\n};\n\nclass Sphere {\n  constructor(center, radius, material) {\n    this.center = center;\n    this.radius = radius;\n    this.material = material;\n  }\n\n  setCenter(center) {\n    this.center = center;\n  }\n\n  hit(ray, tmin, tmax, record) {\n    let oc = _sub_(ray.origin(), this.center);\n\n    let a = dot(ray.direction(), ray.direction());\n    let b = dot(oc, ray.direction());\n\n    let c = _sub_(dot(oc, oc), _mul_(this.radius, this.radius));\n\n    let discriminant = _sub_(_mul_(b, b), _mul_(a, c));\n\n    if (discriminant < 0) return false;\n\n    let temp = _div_(_sub_(_negate_(b), Math.sqrt(discriminant)), a);\n\n    let isValid = temp < tmax && temp > tmin;\n\n    if (!isValid) {\n      temp = _div_(_add_(_negate_(b), Math.sqrt(discriminant)), a);\n      isValid = temp < tmax && temp > tmin;\n    }\n\n    if (isValid) {\n      record.t = temp;\n      record.p = ray.pointAt(temp);\n      record.normal = _div_(_sub_(record.p, this.center), this.radius);\n      record.material = this.material;\n      return true;\n    }\n\n    return false;\n  }\n\n}\n\nconst getCenterByTime = (center1, center2, time1, time2, time) => {\n  return _add_(center1, _mul_(_div_(_sub_(time, time1), _sub_(time2, time1)), _sub_(center2, center1)));\n};\n\nclass MovingSphere {\n  constructor(center1, center2, time1, time2, radius, material) {\n    this.center1 = center1;\n    this.center2 = center2;\n    this.time1 = time1;\n    this.time2 = time2;\n    this.sphere = new Sphere(center1, radius, material);\n  }\n\n  hit(ray, tmin, tmax, record) {\n    let center = getCenterByTime(this.center1, this.center2, this.time1, this.time2, ray.time);\n    this.sphere.setCenter(center);\n    return this.sphere.hit(ray, tmin, tmax, record);\n  }\n\n}\n\nclass HitableList {\n  constructor(list) {\n    this.list = list;\n  }\n\n  hit(ray, tmin, tmax, record) {\n    let tempRecord = createRecord();\n    let hited = false;\n    let closest = tmax;\n\n    for (let object of this.list) {\n      if (object.hit(ray, tmin, closest, tempRecord)) {\n        hited = true;\n        closest = tempRecord.t;\n        Object.assign(record, tempRecord);\n      }\n    }\n\n    return hited;\n  }\n\n  push(...args) {\n    this.list.push(...args);\n  }\n\n}\n\nconst randomInUnitDisk = () => {\n  let p;\n\n  do {\n    let randomVec3 = from(Math.random(), Math.random(), 0.0);\n    p = _sub_(_mul_(2.0, randomVec3), from(1.0, 1.0, 0.0));\n  } while (dot(p, p) >= 1.0);\n\n  return p;\n};\n\nclass Camera {\n  constructor(lookFrom, lookAt, vup, vfov, aspect, aperture, focusDist, time1, time2) {\n    let theta = _div_(_mul_(vfov, Math.PI), 180);\n\n    let halfHeight = Math.tan(_div_(theta, 2));\n\n    let halfWidth = _mul_(halfHeight, aspect);\n\n    let origin = lookFrom;\n    let w = normalize(_sub_(lookFrom, lookAt));\n    let u = normalize(cross(vup, w));\n    let v = cross(w, u);\n\n    let lowerLeftCorner = _sub_(origin, _mul_(focusDist, _add_(_add_(_mul_(u, halfWidth), _mul_(v, halfHeight)), w)));\n\n    let horizontal = _mul_(_mul_(_mul_(focusDist, 2), u), halfWidth);\n\n    let vertical = _mul_(_mul_(_mul_(focusDist, 2), v), halfHeight);\n\n    this.time1 = time1;\n    this.time2 = time2;\n    this.u = u;\n    this.v = v;\n    this.origin = origin;\n    this.lowerLeftCorner = lowerLeftCorner;\n    this.horizontal = horizontal;\n    this.vertical = vertical;\n    this.lensRadius = _div_(aperture, 2);\n  }\n\n  getRay(s, t) {\n    let {\n      origin,\n      lowerLeftCorner,\n      horizontal,\n      vertical\n    } = this;\n\n    let rd = _mul_(this.lensRadius, randomInUnitDisk());\n\n    let offset = _add_(_mul_(this.u, rd[0]), _mul_(this.v, rd[1]));\n\n    let direction = _sub_(_add_(_add_(lowerLeftCorner, _mul_(s, horizontal)), _mul_(t, vertical)), origin);\n\n    let time = _add_(this.time1, _mul_(Math.random(), _sub_(this.time2, this.time1)));\n\n    let ray = new Ray(_add_(origin, offset), _sub_(direction, offset), time);\n    return ray;\n  }\n\n}\n\nconst randomInUnitSphere = () => {\n  let p;\n\n  do {\n    let randomVec3 = from(Math.random(), Math.random(), Math.random());\n    p = _sub_(_mul_(2.0, randomVec3), from(1.0, 1.0, 1.0));\n  } while (vec3.squaredLength(p) >= 1.0);\n\n  return p;\n};\n\nclass LambertianMaterial {\n  constructor(albedo) {\n    this.albedo = albedo;\n  }\n\n  scatter(ray, record, ref) {\n    let target = _add_(_add_(record.p, record.normal), randomInUnitSphere());\n\n    let direction = _sub_(target, record.p);\n\n    ref.scattered = new Ray(record.p, direction, ray.time);\n    ref.attenuation = this.albedo;\n    return true;\n  }\n\n}\n\nconst reflect = (v, n) => {\n  return _sub_(v, _mul_(_mul_(2.0, dot(v, n)), n));\n};\n\nclass MetalMaterial {\n  constructor(albedo, fuzz = 1) {\n    this.albedo = albedo;\n    this.fuzz = Math.min(fuzz, 1);\n  }\n\n  scatter(ray, record, ref) {\n    let reflected = reflect(vec3.normalize(vec3.create(), ray.direction()), record.normal);\n    ref.scattered = new Ray(record.p, _add_(reflected, _mul_(this.fuzz, randomInUnitSphere())));\n    ref.attenuation = this.albedo;\n    return dot(ref.scattered.direction(), record.normal) > 0;\n  }\n\n}\n\nconst refract = (v, normal, ni_over_nt, ref) => {\n  let uv = vec3.normalize(vec3.create(), v);\n  let dt = dot(uv, normal);\n\n  let discriminant = _sub_(1.0, _mul_(_mul_(ni_over_nt, ni_over_nt), _sub_(1.0, _mul_(dt, dt))));\n\n  if (discriminant > 0) {\n    ref.refracted = _sub_(_mul_(ni_over_nt, _sub_(uv, _mul_(normal, dt))), _mul_(normal, Math.sqrt(discriminant)));\n    return true;\n  }\n\n  return false;\n};\n\nconst schlick = (consine, refractIndex) => {\n  let r0 = _div_(_sub_(1, refractIndex), _add_(1, refractIndex));\n\n  r0 = _mul_(r0, r0);\n  return _add_(r0, _mul_(_sub_(1, r0), Math.pow(_sub_(1, consine), 5)));\n};\n\nclass DielectricMaterial {\n  constructor(refractIndex) {\n    this.refractIndex = refractIndex;\n  }\n\n  scatter(ray, record, ref) {\n    let outwardNormal = vec3.create();\n    let reflected = reflect(ray.direction(), record.normal);\n    let ni_over_nt = 0.0;\n    let consine = 0.0;\n    ref.attenuation = from(1.0, 1.0, 1.0);\n    let dotResult = dot(ray.direction(), record.normal);\n\n    if (dotResult > 0) {\n      outwardNormal = _negate_(record.normal);\n      ni_over_nt = this.refractIndex;\n      consine = _div_(_mul_(this.refractIndex, dotResult), vec3.length(ray.direction()));\n    } else {\n      outwardNormal = record.normal;\n      ni_over_nt = _div_(1.0, this.refractIndex);\n      consine = _div_(_negate_(dotResult), vec3.length(ray.direction()));\n    }\n\n    let refractProb = 0.0;\n\n    if (refract(ray.direction(), outwardNormal, ni_over_nt, ref)) {\n      refractProb = schlick(consine, this.refractIndex);\n    } else {\n      refractProb = 1.0;\n    }\n\n    if (Math.random() < refractProb) {\n      ref.scattered = new Ray(record.p, reflected);\n    } else {\n      ref.scattered = new Ray(record.p, ref.refracted);\n    }\n\n    return true;\n  }\n\n}\n\nconst color = (ray, world, depth = 0) => {\n  let record = createRecord();\n\n  if (world.hit(ray, 0.001, Infinity, record)) {\n    let ref = {\n      scattered: null,\n      attenuation: 0\n    };\n\n    if (depth >= 50 || !record.material.scatter(ray, record, ref)) {\n      return from(0.0, 0.0, 0.0);\n    }\n\n    return _mul_(ref.attenuation, color(ref.scattered, world, _add_(depth, 1)));\n  }\n\n  let direction = vec3.normalize(vec3.create(), ray.direction());\n  return lerp(_mul_(0.5, _add_(direction[1], 1.0)), from(1.0, 1.0, 1.0), from(0.5, 0.7, 1.0));\n};\n\nconst randomScene = amount => {\n  let list = [];\n  let range = Math.floor(_div_(Math.sqrt(amount), 2));\n\n  let start = _negate_(range);\n\n  let end = +range;\n  list[0] = new Sphere(from(0.0, -1000, 0), 1000, new LambertianMaterial(from(0.5, 0.5, 0.5)));\n  let i = 1;\n  let based = from(4.0, 0.2, 0.0);\n\n  for (let a = start; a < end; a++) {\n    for (let b = start; b < end; b++) {\n      let chooseMat = Math.random();\n      let center = from(_add_(a, _mul_(0.9, Math.random())), 0.2, _add_(b, _mul_(0.9, Math.random())));\n\n      if (vec3.length(_sub_(center, based)) > 0.9) {\n        if (chooseMat < 0.8) {\n          let material = new LambertianMaterial(from(_mul_(Math.random(), Math.random()), _mul_(Math.random(), Math.random()), _mul_(Math.random(), Math.random()))); // list[i++] = new Sphere(center, 0.2, material)\n          // continue\n\n          list[i++] = new MovingSphere(center, _add_(center, from(0, _mul_(0.5, Math.random()), 0)), 0.0, 1.0, 0.2, material);\n        } else if (chooseMat < 0.95) {\n          let material = new MetalMaterial(from(_mul_(0.5, _add_(1, Math.random())), _mul_(0.5, _add_(1, Math.random())), _mul_(0.5, _add_(1, Math.random()))), _mul_(0.5, Math.random()));\n          list[i++] = new Sphere(center, 0.2, material);\n        } else {\n          list[i++] = new Sphere(center, 0.2, new DielectricMaterial(1.5));\n        }\n      }\n    }\n  }\n\n  list[i++] = new Sphere(from(0.0, 1.0, 0.0), 1.0, new DielectricMaterial(1.5));\n  list[i++] = new Sphere(from(-4.0, 1.0, 0.0), 1.0, new LambertianMaterial(from(0.4, 0.2, 0.1)));\n  list[i++] = new Sphere(from(4.0, 1.0, 0.0), 1.0, new MetalMaterial(from(0.7, 0.6, 0.5), 0.0));\n  return new HitableList(list);\n};\n\nexport default (({\n  width = 800,\n  height = 400,\n  amount = 2,\n  lookFrom = from(13.0, 2.0, 3.0),\n  lookAt = from(0.0, 0.0, 0.0),\n  vup = from(0.0, 1.0, 0.0),\n  vfov = 20,\n  aspect = _div_(width, height),\n  focusDist = 10,\n  aperture = 0.1\n}) => {\n  let nx = width;\n  let ny = height;\n  let camera = new Camera(lookFrom, lookAt, vup, vfov, aspect, aperture, focusDist, 0.0, 1.0);\n  let world = randomScene(amount);\n\n  let renderByPosition = (x, y) => {\n    let u = _div_(_add_(x, Math.random()), nx);\n\n    let v = _div_(_add_(y, Math.random()), ny);\n\n    let ray = camera.getRay(u, v);\n    return color(ray, world);\n  };\n\n  let render = function* () {\n    for (let j = _sub_(ny, 1); j >= 0; j--) {\n      for (let i = 0; i < nx; i++) {\n        let [r, g, b] = renderByPosition(i, j);\n        let a = 1;\n        yield r;\n        yield g;\n        yield b;\n        yield a;\n      }\n    }\n  };\n\n  return {\n    render,\n    renderByPosition\n  };\n});","import React, { useState, useEffect, useRef } from \"react\";\r\nimport createRayTracing from \"./ray-tracing\";\r\n\r\nconst noop = () => {};\r\nconst frame = (f = noop) =>\r\n  new Promise((resolve) => {\r\n    requestAnimationFrame(() => {\r\n      f();\r\n      resolve();\r\n    });\r\n  });\r\n\r\nconst getMSE = (listA, listB) => {\r\n  let sum = 0;\r\n  for (let i = 0; i < listA.length; i++) {\r\n    sum += Math.pow(listA[i] - listB[i], 2);\r\n  }\r\n  return sum / listA.length;\r\n};\r\n\r\nconst incre = function* (start, end, step = 1) {\r\n  while (start <= end) {\r\n    yield start;\r\n    start += step;\r\n  }\r\n};\r\n\r\nconst decre = function* (start, end, step = -1) {\r\n  while (start >= end) {\r\n    yield start;\r\n    start += step;\r\n  }\r\n};\r\n\r\nconst range = function (start, end, step = 1) {\r\n  if (start < end) return incre(start, end, Math.abs(step));\r\n  return decre(start, end, -Math.abs(step));\r\n};\r\n\r\nconst toggle = function* (a, b) {\r\n  while (true) {\r\n    let valueA = a.next();\r\n    let valueB = b.next();\r\n    if (valueA.done && valueB.done) break;\r\n    if (!valueA.done) yield valueA.value;\r\n    if (!valueB.done) yield valueB.value;\r\n  }\r\n};\r\n\r\nconst spread = function* (start, end, step = 1) {\r\n  let middle = Math.floor((end - start) / 2);\r\n  let source = toggle(\r\n    range(middle, start, step),\r\n    range(middle + step, end, step)\r\n  );\r\n  for (let v of source) yield v;\r\n};\r\n\r\n// mean squared error\r\nconst sortByMSE = (prev, current) => {\r\n  let result = [];\r\n\r\n  for (let i = 0; i < prev.length; i += 4) {\r\n    let index = Math.floor(i / 4);\r\n    let listA = [prev[i + 0], prev[i + 1], prev[i + 2], prev[i + 3]];\r\n    let listB = [\r\n      current[i + 0],\r\n      current[i + 1],\r\n      current[i + 2],\r\n      current[i + 3],\r\n    ];\r\n\r\n    result[index] = {\r\n      index,\r\n      value: getMSE(listA, listB),\r\n    };\r\n  }\r\n\r\n  return result.sort((a, b) => b.value - a.value);\r\n};\r\n\r\nconst toColor = (value) => {\r\n  return Math.floor(255.99 * Math.sqrt(value));\r\n};\r\n\r\nexport default function RayTracing(props) {\r\n  let [time, setTime] = useState(0);\r\n  let ref = useRef();\r\n  let deubgRef = useRef();\r\n  let width = 800;\r\n  let height = 400;\r\n\r\n  useEffect(() => {\r\n    let canvas = ref.current;\r\n    let debugCanvas = deubgRef.current;\r\n    let ctx = canvas.getContext(\"2d\");\r\n    let debugCtx = debugCanvas.getContext(\"2d\");\r\n    let imageData = ctx.createImageData(width, height);\r\n    let debugImageData = debugCtx.createImageData(width, height);\r\n    let ray = createRayTracing({ width, height, amount: props.counts || 0 });\r\n    let data = new Float32Array(width * height * 4);\r\n    let prevImageData = new Float32Array(width * height * 4);\r\n    let currImageData = new Float32Array(width * height * 4);\r\n    let renderCount = new Float32Array(width * height * 4);\r\n    let innerCount = 1;\r\n    let innerTime = 0;\r\n    let tid = null;\r\n    let over = false;\r\n\r\n    let renderToCanvas = () => {\r\n      ctx.fillColor = `rgba(0, 0, 0, 1)`;\r\n      ctx.clearRect(0, 0, width, height);\r\n      ctx.putImageData(imageData, 0, 0);\r\n    };\r\n\r\n    let showDebugInfo = () => {\r\n      let data = renderCount;\r\n      for (let i = 0; i < data.length; i++) {\r\n        if ((i + 1) % 4 === 0) {\r\n          debugImageData.data[i] = 255;\r\n        } else {\r\n          debugImageData.data[i] = data[i];\r\n        }\r\n      }\r\n      debugCtx.clearRect(0, 0, width, height);\r\n      debugCtx.putImageData(debugImageData, 0, 0);\r\n    };\r\n\r\n    let renderByPosition = (x, y) => {\r\n      let [r, g, b, a = 1] = ray.renderByPosition(x, y);\r\n      let i = ((height - 1 - y) * width + x) * 4;\r\n\r\n      data[i + 0] += r;\r\n      data[i + 1] += g;\r\n      data[i + 2] += b;\r\n      data[i + 3] += a;\r\n\r\n      renderCount[i + 0] += 1;\r\n      renderCount[i + 1] += 1;\r\n      renderCount[i + 2] += 1;\r\n      renderCount[i + 3] += 1;\r\n\r\n      prevImageData[i + 0] = imageData.data[i + 0];\r\n      prevImageData[i + 1] = imageData.data[i + 1];\r\n      prevImageData[i + 2] = imageData.data[i + 2];\r\n      prevImageData[i + 3] = imageData.data[i + 3];\r\n\r\n      imageData.data[i + 0] = toColor(data[i + 0] / renderCount[i + 0]);\r\n      imageData.data[i + 1] = toColor(data[i + 1] / renderCount[i + 1]);\r\n      imageData.data[i + 2] = toColor(data[i + 2] / renderCount[i + 2]);\r\n      imageData.data[i + 3] = toColor(data[i + 3] / renderCount[i + 3]);\r\n\r\n      currImageData[i + 0] = imageData.data[i + 0];\r\n      currImageData[i + 1] = imageData.data[i + 1];\r\n      currImageData[i + 2] = imageData.data[i + 2];\r\n      currImageData[i + 3] = imageData.data[i + 3];\r\n    };\r\n\r\n    let render = async function (step = 1) {\r\n      let start = Date.now();\r\n      let duration = 0;\r\n\r\n      for (let y of spread(0, height - 1, step)) {\r\n        for (let x of range(0, width - 1, step)) {\r\n          if (over) return;\r\n\r\n          renderByPosition(x, y);\r\n          duration = Date.now() - start;\r\n          if (duration % 100 === 0) {\r\n            setTime(innerTime + duration);\r\n            await frame(() => {\r\n              renderToCanvas();\r\n              showDebugInfo();\r\n            });\r\n          }\r\n        }\r\n      }\r\n\r\n      if (step === 1) innerCount += 1;\r\n      renderToCanvas();\r\n      showDebugInfo();\r\n      setTime((innerTime += duration));\r\n      if (innerCount > 2) {\r\n        scheduleRender();\r\n      } else {\r\n        tid = requestAnimationFrame(() => render());\r\n      }\r\n    };\r\n\r\n    let scheduleRender = async (count = 0) => {\r\n      let list = sortByMSE(prevImageData, currImageData);\r\n      let start = Date.now();\r\n      let duration = 0;\r\n\r\n      for (let i = 0; i < 20000; i++) {\r\n        let item = list[i];\r\n        let x = item.index % width;\r\n        let y = height - Math.floor(item.index / width);\r\n\r\n        renderByPosition(x, y);\r\n        duration = Date.now() - start;\r\n\r\n        if (duration % 100 === 0) {\r\n          setTime(innerTime + duration);\r\n          await frame(() => {\r\n            renderToCanvas();\r\n            showDebugInfo();\r\n          });\r\n        }\r\n        if (over) return;\r\n      }\r\n\r\n      if (over) return;\r\n\r\n      renderToCanvas();\r\n      setTime((innerTime += Date.now() - start));\r\n      tid = requestAnimationFrame(() => {\r\n        if (count < 5) {\r\n          scheduleRender(count + 1);\r\n        } else {\r\n          render();\r\n        }\r\n      });\r\n    };\r\n\r\n    render(3);\r\n\r\n    return () => {\r\n      over = true;\r\n      clearTimeout(tid);\r\n    };\r\n  }, [props.counts]);\r\n\r\n  return (\r\n    <>\r\n      <h2>Ray tracing via JavaScript</h2>\r\n      <h3>Time: {(time / 1000).toFixed(2)}s</h3>\r\n      <canvas\r\n        width={width}\r\n        height={height}\r\n        ref={ref}\r\n        style={{ background: \"#000\", display: \"block\", margin: \"0 auto\" }}\r\n      />\r\n      <br />\r\n      <canvas\r\n        width={width}\r\n        height={height}\r\n        ref={deubgRef}\r\n        style={{ display: \"block\", margin: \"0 auto\" }}\r\n      />\r\n    </>\r\n  );\r\n}\r\n","import React, {\r\n  useEffect,\r\n  useState,\r\n  useRef,\r\n  MouseEventHandler,\r\n  EventHandler,\r\n} from \"react\";\r\n\r\nconst noop = () => {};\r\nconst frame = (f = noop) =>\r\n  new Promise((resolve) => {\r\n    requestAnimationFrame(() => {\r\n      f();\r\n      resolve();\r\n    });\r\n  });\r\n\r\nconst getMSE = (listA: number[], listB: number[]) => {\r\n  let sum = 0;\r\n  for (let i = 0; i < listA.length; i++) {\r\n    sum += Math.pow(listA[i] - listB[i], 2);\r\n  }\r\n  return sum / listA.length;\r\n};\r\n\r\nconst incre = function* (start: number, end: number, step = 1) {\r\n  while (start <= end) {\r\n    yield start;\r\n    start += step;\r\n  }\r\n};\r\n\r\nconst decre = function* (start: number, end: number, step = -1) {\r\n  while (start >= end) {\r\n    yield start;\r\n    start += step;\r\n  }\r\n};\r\n\r\nconst range = function (start: number, end: number, step = 1) {\r\n  if (start < end) return incre(start, end, Math.abs(step));\r\n  return decre(start, end, -Math.abs(step));\r\n};\r\n\r\nconst toggle = function* (\r\n  a: Generator<number, void, unknown>,\r\n  b: Generator<number, void, unknown>\r\n) {\r\n  while (true) {\r\n    let valueA = a.next();\r\n    let valueB = b.next();\r\n    if (valueA.done && valueB.done) break;\r\n    if (!valueA.done) yield valueA.value;\r\n    if (!valueB.done) yield valueB.value;\r\n  }\r\n};\r\n\r\nconst spread = function* (\r\n  start: number,\r\n  end: number,\r\n  step = 1\r\n): Generator<number, void, unknown> {\r\n  let middle = Math.floor((end - start) / 2);\r\n  let source = toggle(\r\n    range(middle, start, step),\r\n    range(middle + step, end, step)\r\n  );\r\n  for (let v of source) yield v;\r\n};\r\n\r\n// mean squared error\r\nconst sortByMSE = (prev: Float32Array, current: Float32Array) => {\r\n  let result = [];\r\n\r\n  for (let i = 0; i < prev.length; i += 4) {\r\n    let index = Math.floor(i / 4);\r\n    let listA = [prev[i + 0], prev[i + 1], prev[i + 2], prev[i + 3]];\r\n    let listB = [\r\n      current[i + 0],\r\n      current[i + 1],\r\n      current[i + 2],\r\n      current[i + 3],\r\n    ];\r\n\r\n    result[index] = {\r\n      index,\r\n      value: getMSE(listA, listB),\r\n    };\r\n  }\r\n\r\n  return result.sort((a, b) => b.value - a.value);\r\n};\r\n\r\nconst toColor = (value: number) => {\r\n  return Math.floor(255.99 * Math.sqrt(value));\r\n};\r\n\r\nexport default React.lazy(async () => {\r\n  let { Scene } = await import(\"../../../ray-tracing-wasm\");\r\n\r\n  let RayTracing: React.FC<{ counts: number }> = function RustRayTracing(\r\n    props\r\n  ) {\r\n    let [time, setTime] = useState(0);\r\n    let ref = useRef<HTMLCanvasElement | null>(null);\r\n    let deubgRef = useRef<HTMLCanvasElement | null>(null);\r\n    let width = 800;\r\n    let height = 400;\r\n\r\n    useEffect(() => {\r\n      if (!ref.current) return;\r\n      if (!deubgRef.current) return;\r\n\r\n      let canvas = ref.current;\r\n      let debugCanvas = deubgRef.current;\r\n      let ctx = canvas.getContext(\"2d\");\r\n      let debugCtx = debugCanvas.getContext(\"2d\");\r\n\r\n      if (!ctx) return;\r\n      if (!debugCtx) return;\r\n\r\n      ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);\r\n      debugCtx.clearRect(\r\n        0,\r\n        0,\r\n        debugCanvas.clientWidth,\r\n        debugCanvas.clientHeight\r\n      );\r\n\r\n      let imageData = ctx.createImageData(width, height);\r\n      let debugImageData = debugCtx.createImageData(width, height);\r\n      let ray = new Scene(width, height, 50);\r\n      let data = new Float32Array(width * height * 4);\r\n      let prevImageData = new Float32Array(width * height * 4);\r\n      let currImageData = new Float32Array(width * height * 4);\r\n      let renderCount = new Float32Array(width * height * 4);\r\n      let innerCount = 1;\r\n      let innerTime = 0;\r\n      let tid: any = null;\r\n      let over = false;\r\n\r\n      ray.random_scene(props.counts || 0);\r\n\r\n      let reset = () => {\r\n        if (!ctx) return;\r\n        if (!debugCtx) return;\r\n\r\n        debugCtx.clearRect(\r\n          0,\r\n          0,\r\n          debugCanvas.clientWidth,\r\n          debugCanvas.clientHeight\r\n        );\r\n        imageData = ctx.createImageData(width, height);\r\n        debugImageData = debugCtx.createImageData(width, height);\r\n        data = new Float32Array(width * height * 4);\r\n        prevImageData = new Float32Array(width * height * 4);\r\n        currImageData = new Float32Array(width * height * 4);\r\n        renderCount = new Float32Array(width * height * 4);\r\n        innerCount = 1;\r\n        innerTime = 0;\r\n        tid = null;\r\n        over = false;\r\n      };\r\n\r\n      let renderToCanvas = () => {\r\n        if (!ctx) return;\r\n        ctx.fillStyle = `rgba(0, 0, 0, 1)`;\r\n        ctx.clearRect(0, 0, width, height);\r\n        ctx.putImageData(imageData, 0, 0);\r\n      };\r\n\r\n      let showDebugInfo = () => {\r\n        if (!debugCtx) return;\r\n        let data = renderCount;\r\n        for (let i = 0; i < data.length; i++) {\r\n          if ((i + 1) % 4 === 0) {\r\n            debugImageData.data[i] = 255;\r\n          } else {\r\n            debugImageData.data[i] = data[i];\r\n          }\r\n        }\r\n        debugCtx.clearRect(0, 0, width, height);\r\n        debugCtx.putImageData(debugImageData, 0, 0);\r\n      };\r\n\r\n      let renderByPosition = (x: number, y: number) => {\r\n        if (y >= 400) debugger;\r\n        let [r, g, b, a = 1] = ray.render_by_position(x, y);\r\n        let i = ((height - 1 - y) * width + x) * 4;\r\n\r\n        data[i + 0] += r;\r\n        data[i + 1] += g;\r\n        data[i + 2] += b;\r\n        data[i + 3] += a;\r\n\r\n        renderCount[i + 0] += 1;\r\n        renderCount[i + 1] += 1;\r\n        renderCount[i + 2] += 1;\r\n        renderCount[i + 3] += 1;\r\n\r\n        prevImageData[i + 0] = imageData.data[i + 0];\r\n        prevImageData[i + 1] = imageData.data[i + 1];\r\n        prevImageData[i + 2] = imageData.data[i + 2];\r\n        prevImageData[i + 3] = imageData.data[i + 3];\r\n\r\n        imageData.data[i + 0] = toColor(data[i + 0] / renderCount[i + 0]);\r\n        imageData.data[i + 1] = toColor(data[i + 1] / renderCount[i + 1]);\r\n        imageData.data[i + 2] = toColor(data[i + 2] / renderCount[i + 2]);\r\n        imageData.data[i + 3] = toColor(data[i + 3] / renderCount[i + 3]);\r\n\r\n        currImageData[i + 0] = imageData.data[i + 0];\r\n        currImageData[i + 1] = imageData.data[i + 1];\r\n        currImageData[i + 2] = imageData.data[i + 2];\r\n        currImageData[i + 3] = imageData.data[i + 3];\r\n      };\r\n\r\n      let render = async function (step = 1) {\r\n        let start = Date.now();\r\n        let duration = 0;\r\n        let yieldCount = 0;\r\n\r\n        for (let y of spread(0, height - 1, step)) {\r\n          for (let x of range(0, width - 1, step)) {\r\n            if (over) return;\r\n\r\n            renderByPosition(x, y);\r\n            duration = Date.now() - start;\r\n            if (duration / 100 > yieldCount) {\r\n              yieldCount += 1;\r\n              if (over) return\r\n              setTime(innerTime + duration);\r\n              await frame(() => {\r\n                renderToCanvas();\r\n                showDebugInfo();\r\n              });\r\n            }\r\n          }\r\n        }\r\n\r\n        if (step === 1) innerCount += 1;\r\n        renderToCanvas();\r\n        showDebugInfo();\r\n        if (over) return\r\n        setTime((innerTime += duration));\r\n\r\n        // tid = requestAnimationFrame(() => render(step));\r\n        // return;\r\n        if (innerCount > 2) {\r\n          scheduleRender();\r\n        } else {\r\n          tid = requestAnimationFrame(() => render());\r\n        }\r\n      };\r\n\r\n      let scheduleRender = async (count = 0) => {\r\n        let list = sortByMSE(prevImageData, currImageData);\r\n        let start = Date.now();\r\n        let duration = 0;\r\n\r\n        for (let i = 0; i < 20000; i++) {\r\n          let item = list[i];\r\n          let x = item.index % width;\r\n          let y = height - Math.max(Math.floor(item.index / width), 1);\r\n          renderByPosition(x, y);\r\n          duration = Date.now() - start;\r\n\r\n          if (duration % 100 === 0) {\r\n            if (over) return\r\n            setTime(innerTime + duration);\r\n            await frame(() => {\r\n              renderToCanvas();\r\n              showDebugInfo();\r\n            });\r\n          }\r\n          if (over) return;\r\n        }\r\n\r\n        if (over) return;\r\n\r\n        renderToCanvas();\r\n        setTime((innerTime += Date.now() - start));\r\n        tid = requestAnimationFrame(() => {\r\n          if (count < 5) {\r\n            scheduleRender(count + 1);\r\n          } else {\r\n            render();\r\n          }\r\n        });\r\n      };\r\n\r\n      render(3);\r\n\r\n      let handleKeyDown = (event: HTMLElementEventMap[\"keydown\"]) => {\r\n        let number = 0;\r\n\r\n        switch (event.key) {\r\n          case \"ArrowUp\":\r\n          case \"w\":\r\n            number = 0;\r\n            break;\r\n          case \"ArrowDown\":\r\n          case \"s\":\r\n            number = 1;\r\n            break;\r\n\r\n          case \"ArrowLeft\":\r\n          case \"a\":\r\n            number = 2;\r\n            break;\r\n          case \"ArrowRight\":\r\n          case \"d\":\r\n            number = 3;\r\n            break;\r\n          default:\r\n            return;\r\n        }\r\n\r\n        ray.process_keyboard(number);\r\n        reset();\r\n      };\r\n\r\n      document.addEventListener(\"keydown\", handleKeyDown, false);\r\n\r\n      return () => {\r\n        document.removeEventListener(\"keydown\", handleKeyDown, false);\r\n        over = true;\r\n        clearTimeout(tid);\r\n      };\r\n    }, [props.counts]);\r\n\r\n    return (\r\n      <>\r\n        <h2>Ray tracing via Rust</h2>\r\n        <h3>Time: {(time / 1000).toFixed(2)}s</h3>\r\n        <div>Press arrow keys or w/s/a/d to change the viewpoint</div>\r\n        <canvas\r\n          width={width}\r\n          height={height}\r\n          ref={ref}\r\n          style={{\r\n            background: \"#000\",\r\n            display: \"block\",\r\n            margin: \"0 auto\",\r\n          }}\r\n        />\r\n        <br />\r\n        <canvas\r\n          width={width}\r\n          height={height}\r\n          ref={deubgRef}\r\n          style={{ display: \"block\", margin: \"0 auto\" }}\r\n        />\r\n      </>\r\n    );\r\n  };\r\n\r\n  return { default: RayTracing };\r\n});\r\n","import React, {\r\n  useEffect,\r\n  useState,\r\n  useRef,\r\n  MouseEventHandler,\r\n  EventHandler,\r\n} from \"react\";\r\nimport throttle from \"lodash.throttle\";\r\n\r\nconst noop = () => {};\r\nconst frame = (f = noop) =>\r\n  new Promise((resolve) => {\r\n    requestAnimationFrame(() => {\r\n      f();\r\n      resolve();\r\n    });\r\n  });\r\n\r\nconst toColor = (value: number) => {\r\n  return Math.floor(255.99 * Math.sqrt(value));\r\n};\r\n\r\nexport default React.lazy(async () => {\r\n  let { Scene } = await import(\"../../../ray-tracing-wasm\");\r\n\r\n  let RayTracing: React.FC<{ counts: number }> = function RustRayTracing(\r\n    props\r\n  ) {\r\n    let [time, setTime] = useState(0);\r\n    let ref = useRef<HTMLCanvasElement | null>(null);\r\n    let deubgRef = useRef<HTMLCanvasElement | null>(null);\r\n    let width = 200;\r\n    let height = 100;\r\n\r\n    useEffect(() => {\r\n      if (!ref.current) return;\r\n\r\n      let canvas = ref.current;\r\n      let debugCanvas = deubgRef.current;\r\n      let ctx = canvas.getContext(\"2d\");\r\n\r\n      if (!ctx) return;\r\n\r\n      ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);\r\n\r\n      let imageData = ctx.createImageData(width, height);\r\n      let ray = new Scene(width, height, 50);\r\n      let data = new Float32Array(width * height * 4);\r\n      let prevImageData = new Float32Array(width * height * 4);\r\n      let currImageData = new Float32Array(width * height * 4);\r\n      let renderCount = new Float32Array(width * height * 4);\r\n      let innerCount = 1;\r\n      let innerTime = 0;\r\n      let tid: any = null;\r\n      let over = false;\r\n\r\n      ray.random_scene(100);\r\n\r\n      let reset = () => {\r\n        if (!ctx) return;\r\n        imageData = ctx.createImageData(width, height);\r\n        data = new Float32Array(width * height * 4);\r\n        prevImageData = new Float32Array(width * height * 4);\r\n        currImageData = new Float32Array(width * height * 4);\r\n        renderCount = new Float32Array(width * height * 4);\r\n        innerCount += 1;\r\n        innerTime = 0;\r\n        tid = null;\r\n        over = false;\r\n      };\r\n\r\n      let renderToCanvas = () => {\r\n        if (!ctx) return;\r\n        ctx.fillStyle = `rgba(0, 0, 0, 1)`;\r\n        ctx.clearRect(0, 0, width, height);\r\n        ctx.putImageData(imageData, 0, 0);\r\n      };\r\n\r\n      let render = async function () {\r\n        if (over) return\r\n        let currentCount = innerCount;\r\n        let start = Date.now();\r\n        let duration = 0;\r\n        let list = ray.render();\r\n\r\n        for (let i = 0; i < list.length; ) {\r\n          let offset = (i / 3) * 4;\r\n          let r = list[i++];\r\n          let g = list[i++];\r\n          let b = list[i++];\r\n          let a = 1;\r\n\r\n          data[offset + 0] += r;\r\n          data[offset + 1] += g;\r\n          data[offset + 2] += b;\r\n          data[offset + 3] += a;\r\n\r\n          renderCount[offset + 0] += 1;\r\n          renderCount[offset + 1] += 1;\r\n          renderCount[offset + 2] += 1;\r\n          renderCount[offset + 3] += 1;\r\n\r\n          prevImageData[offset + 0] = imageData.data[offset + 0];\r\n          prevImageData[offset + 1] = imageData.data[offset + 1];\r\n          prevImageData[offset + 2] = imageData.data[offset + 2];\r\n          prevImageData[offset + 3] = imageData.data[offset + 3];\r\n\r\n          imageData.data[offset + 0] = toColor(\r\n            data[offset + 0] / renderCount[offset + 0]\r\n          );\r\n          imageData.data[offset + 1] = toColor(\r\n            data[offset + 1] / renderCount[offset + 1]\r\n          );\r\n          imageData.data[offset + 2] = toColor(\r\n            data[offset + 2] / renderCount[offset + 2]\r\n          );\r\n          imageData.data[offset + 3] = toColor(\r\n            data[offset + 3] / renderCount[offset + 3]\r\n          );\r\n\r\n          currImageData[offset + 0] = imageData.data[offset + 0];\r\n          currImageData[offset + 1] = imageData.data[offset + 1];\r\n          currImageData[offset + 2] = imageData.data[offset + 2];\r\n          currImageData[offset + 3] = imageData.data[offset + 3];\r\n        }\r\n\r\n        if (over) return\r\n        setTime(innerTime + duration);\r\n        await frame(() => {\r\n          if (currentCount === innerCount) {\r\n            renderToCanvas();\r\n          }\r\n          let duration = Date.now() - start;\r\n          if (over) return\r\n          setTime((innerTime += duration));\r\n        });\r\n\r\n        tid = requestAnimationFrame(render);\r\n      };\r\n\r\n      render();\r\n\r\n      let handleKeyDown = throttle((event: HTMLElementEventMap[\"keydown\"]) => {\r\n        let number = 0;\r\n\r\n        switch (event.key) {\r\n          case \"ArrowUp\":\r\n          case \"w\":\r\n            number = 0;\r\n            break;\r\n          case \"ArrowDown\":\r\n          case \"s\":\r\n            number = 1;\r\n            break;\r\n\r\n          case \"ArrowLeft\":\r\n          case \"a\":\r\n            number = 2;\r\n            break;\r\n          case \"ArrowRight\":\r\n          case \"d\":\r\n            number = 3;\r\n            break;\r\n          default:\r\n            return;\r\n        }\r\n\r\n        ray.process_keyboard(number);\r\n        reset();\r\n      }, 200);\r\n\r\n      document.addEventListener(\"keydown\", handleKeyDown, false);\r\n\r\n      return () => {\r\n        document.removeEventListener(\"keydown\", handleKeyDown, false);\r\n        over = true;\r\n        clearTimeout(tid);\r\n      };\r\n    }, [props.counts]);\r\n\r\n    return (\r\n      <>\r\n        <h2>Ray tracing via Rust</h2>\r\n        <h3>Time: {(time / 1000).toFixed(2)}s</h3>\r\n        <div>Press arrow keys or w/s/a/d to change the viewpoint</div>\r\n        <div\r\n          style={{\r\n            height: 400,\r\n          }}\r\n        >\r\n          <canvas\r\n            width={width}\r\n            height={height}\r\n            ref={ref}\r\n            style={{\r\n              display: \"block\",\r\n              marginLeft: \"auto\",\r\n              marginRight: \"auto\",\r\n              marginTop: (400 - height) / 2,\r\n              background: \"#000\",\r\n              transform: \"scale(4)\",\r\n            }}\r\n          />\r\n        </div>\r\n      </>\r\n    );\r\n  };\r\n\r\n  return { default: RayTracing };\r\n});\r\n","import React, { useEffect, useState, useRef, Suspense } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport JsRayTracing from \"./pure-js\";\nimport RustRayTracing from \"./rust-wasm\";\nimport SmallRustRayTracing from './rust-wasm/small'\nimport \"antd/dist/antd.css\";\nimport \"./index.css\";\n\nimport { Layout, Menu } from \"antd\";\n\nconst { Header, Content, Footer } = Layout;\n\nconst Components = {\n  JavaScript: JsRayTracing,\n  Rust: RustRayTracing,\n  ['Rust: Small image']: SmallRustRayTracing\n};\n\ntype Languages = keyof typeof Components;\n\nconst App = () => {\n  let [type, setType] = useState<Languages>(\"Rust\");\n  let [counts, setCounts] = useState(100);\n\n  let Target = Components[type] || JsRayTracing;\n\n  let handleCountChange: React.ChangeEventHandler<HTMLInputElement> = (\n    event\n  ) => {\n    setCounts(parseInt(event.target.value, 10));\n  };\n\n  return (\n    <Layout className='layout'>\n      <Header>\n        <div className='logo' />\n        <Menu theme='dark' mode='horizontal' selectedKeys={[type]}>\n          {Object.keys(Components).map((name) => {\n            let handleClick = () => {\n              setType(name as Languages);\n            };\n            return (\n              <Menu.Item key={name} onClick={handleClick}>\n                {name}\n              </Menu.Item>\n            );\n          })}\n        </Menu>\n      </Header>\n      <Content style={{ padding: \"0 250px\" }}>\n        <div className='site-layout-content'>\n          <Suspense fallback='loading...'>\n            <Target counts={counts} />\n          </Suspense>\n        </div>\n      </Content>\n      <Footer style={{ textAlign: \"center\" }}>\n        <a href='https://github.com/Lucifier129/rust-ray-tracing-demo'>\n          Ray Tracing Demos Created by 工业聚\n        </a>\n      </Footer>\n    </Layout>\n  );\n};\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n","const { vec3 } = require('gl-matrix')\r\n\r\nconst isVec3 = obj => obj instanceof Float32Array\r\nconst toVec3 = n => vec3.fromValues(n, n, n)\r\n\r\nlet _add_ = function(left, right) {\r\n  if (!isVec3(left) && !isVec3(right)) return left + right\r\n\r\n  if (!isVec3(left)) left = toVec3(left)\r\n  if (!isVec3(right)) right = toVec3(right)\r\n\r\n  return vec3.add(vec3.create(), left, right)\r\n}\r\n\r\nlet _sub_ = function(left, right) {\r\n  if (!isVec3(left) && !isVec3(right)) return left - right\r\n\r\n  if (!isVec3(left)) left = toVec3(left)\r\n  if (!isVec3(right)) right = toVec3(right)\r\n\r\n  return vec3.sub(vec3.create(), left, right)\r\n}\r\n\r\nlet _mul_ = function(left, right) {\r\n  if (!isVec3(left) && !isVec3(right)) return left * right\r\n\r\n  if (!isVec3(left)) left = toVec3(left)\r\n  if (!isVec3(right)) right = toVec3(right)\r\n\r\n  return vec3.mul(vec3.create(), left, right)\r\n}\r\n\r\nlet _div_ = function(left, right) {\r\n  if (!isVec3(left) && !isVec3(right)) return left / right\r\n\r\n  if (!isVec3(left)) left = toVec3(left)\r\n  if (!isVec3(right)) right = toVec3(right)\r\n\r\n  return vec3.div(vec3.create(), left, right)\r\n}\r\n\r\nlet _negate_ = function(operand) {\r\n  if (!isVec3(operand)) return -operand\r\n  return vec3.negate(vec3.create(), operand)\r\n}\r\n\r\nmodule.exports = {\r\n  _add_,\r\n  _sub_,\r\n  _mul_,\r\n  _div_,\r\n  _negate_\r\n}\r\n"],"sourceRoot":""}